"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
<<<<<<< HEAD
exports.default = exports.ESLintWebpackPlugin = void 0;
=======
exports.default = void 0;
>>>>>>> e746c2bfaec608273ddba2a9c3f88698eea4a1d6

var _path = require("path");

var _arrify = _interopRequireDefault(require("arrify"));

<<<<<<< HEAD
var _micromatch = _interopRequireDefault(require("micromatch"));
=======
var _micromatch = require("micromatch");
>>>>>>> e746c2bfaec608273ddba2a9c3f88698eea4a1d6

var _options = require("./options");

var _linter = _interopRequireDefault(require("./linter"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

<<<<<<< HEAD
=======
// @ts-ignore

>>>>>>> e746c2bfaec608273ddba2a9c3f88698eea4a1d6
/** @typedef {import('webpack').Compiler} Compiler */

/** @typedef {import('./options').Options} Options */
const ESLINT_PLUGIN = 'ESLintWebpackPlugin';
<<<<<<< HEAD
=======
let counter = 0;
>>>>>>> e746c2bfaec608273ddba2a9c3f88698eea4a1d6

class ESLintWebpackPlugin {
  /**
   * @param {Options} options
   */
  constructor(options = {}) {
<<<<<<< HEAD
=======
    this.key = ESLINT_PLUGIN;
>>>>>>> e746c2bfaec608273ddba2a9c3f88698eea4a1d6
    this.options = (0, _options.getOptions)(options);
    this.run = this.run.bind(this);
  }
  /**
   * @param {Compiler} compiler
   * @returns {void}
   */


  apply(compiler) {
<<<<<<< HEAD
    if (!this.options.lintDirtyModulesOnly) {
      compiler.hooks.run.tapPromise(ESLINT_PLUGIN, this.run);
=======
    // Generate key for each compilation,
    // this differentiates one from the other when being cached.
    this.key = compiler.name || `${this.key}_${counter += 1}`; // If `lintDirtyModulesOnly` is disabled,
    // execute the linter on the build

    if (!this.options.lintDirtyModulesOnly) {
      compiler.hooks.run.tapPromise(this.key, this.run);
>>>>>>> e746c2bfaec608273ddba2a9c3f88698eea4a1d6
    } // TODO: Figure out want `compiler.watching` is and how to use it in Webpack5.
    // From my testing of compiler.watch() ... compiler.watching is always
    // undefined (webpack 4 doesn't define it either) I'm leaving it out
    // for now.


<<<<<<< HEAD
    compiler.hooks.watchRun.tapPromise(ESLINT_PLUGIN, this.run);
=======
    let isFirstRun = this.options.lintDirtyModulesOnly;
    compiler.hooks.watchRun.tapPromise(this.key, c => {
      if (isFirstRun) {
        isFirstRun = false;
        return Promise.resolve();
      }

      return this.run(c);
    });
>>>>>>> e746c2bfaec608273ddba2a9c3f88698eea4a1d6
  }
  /**
   * @param {Compiler} compiler
   */


  async run(compiler) {
    // Do not re-hook
    if ( // @ts-ignore
<<<<<<< HEAD
    compiler.hooks.thisCompilation.taps.find( // @ts-ignore
    ({
      name
    }) => name === ESLINT_PLUGIN)) {
=======
    compiler.hooks.thisCompilation.taps.find(({
      name
    }) => name === this.key)) {
>>>>>>> e746c2bfaec608273ddba2a9c3f88698eea4a1d6
      return;
    }

    const options = { ...this.options,
<<<<<<< HEAD
      exclude: (0, _utils.parseFiles)(this.options.exclude || 'node_modules', this.getContext(compiler)),
=======
      exclude: (0, _utils.parseFiles)(this.options.exclude || [], this.getContext(compiler)),
>>>>>>> e746c2bfaec608273ddba2a9c3f88698eea4a1d6
      extensions: (0, _arrify.default)(this.options.extensions),
      files: (0, _utils.parseFiles)(this.options.files || '', this.getContext(compiler))
    };
    const wanted = (0, _utils.parseFoldersToGlobs)(options.files, options.extensions);
<<<<<<< HEAD
    const exclude = (0, _utils.parseFoldersToGlobs)(options.exclude, []);
    compiler.hooks.thisCompilation.tap(ESLINT_PLUGIN, compilation => {
=======
    const exclude = (0, _utils.parseFoldersToGlobs)(this.options.exclude ? options.exclude : '**/node_modules/**', []);
    compiler.hooks.thisCompilation.tap(this.key, compilation => {
>>>>>>> e746c2bfaec608273ddba2a9c3f88698eea4a1d6
      /** @type {import('./linter').Linter} */
      let lint;
      /** @type {import('./linter').Reporter} */

      let report;

      try {
        ({
          lint,
          report
<<<<<<< HEAD
        } = (0, _linter.default)(options, compilation));
      } catch (e) {
        compilation.errors.push(e);
        return;
      } // @ts-ignore


      const processModule = module => {
        if (module.resource) {
          const file = module.resource.split('?')[0];

          if (file && _micromatch.default.isMatch(file, wanted) && !_micromatch.default.isMatch(file, exclude)) {
            // Queue file for linting.
            lint(file);
          }
        }
      }; // Gather Files to lint


      compilation.hooks.succeedModule.tap(ESLINT_PLUGIN, processModule); // await and interpret results

      compilation.hooks.afterSeal.tapPromise(ESLINT_PLUGIN, processResults);
=======
        } = (0, _linter.default)(this.key, options, compilation));
      } catch (e) {
        compilation.errors.push(e);
        return;
      }
      /** @type {string[]} */


      const files = []; // @ts-ignore
      // Add the file to be linted

      compilation.hooks.succeedModule.tap(this.key, ({
        resource
      }) => {
        if (resource) {
          const [file] = resource.split('?');

          if (file && !files.includes(file) && (0, _micromatch.isMatch)(file, wanted, {
            dot: true
          }) && !(0, _micromatch.isMatch)(file, exclude, {
            dot: true
          })) {
            files.push(file);
          }
        }
      }); // Lint all files added

      compilation.hooks.finishModules.tap(this.key, () => {
        if (files.length > 0) {
          lint(files);
        }
      }); // await and interpret results

      compilation.hooks.additionalAssets.tapPromise(this.key, processResults);
>>>>>>> e746c2bfaec608273ddba2a9c3f88698eea4a1d6

      async function processResults() {
        const {
          errors,
          warnings,
          generateReportAsset
        } = await report();

<<<<<<< HEAD
        if (warnings) {
          // @ts-ignore
          compilation.warnings.push(warnings);
        }

        if (errors) {
          // @ts-ignore
          compilation.errors.push(errors);
=======
        if (warnings && !options.failOnWarning) {
          // @ts-ignore
          compilation.warnings.push(warnings);
        } else if (warnings && options.failOnWarning) {
          // @ts-ignore
          compilation.errors.push(warnings);
        }

        if (errors && options.failOnError) {
          // @ts-ignore
          compilation.errors.push(errors);
        } else if (errors && !options.failOnError) {
          // @ts-ignore
          compilation.warnings.push(errors);
>>>>>>> e746c2bfaec608273ddba2a9c3f88698eea4a1d6
        }

        if (generateReportAsset) {
          await generateReportAsset(compilation);
        }
      }
    });
  }
  /**
   *
   * @param {Compiler} compiler
   * @returns {string}
   */


  getContext(compiler) {
    if (!this.options.context) {
      return String(compiler.options.context);
    }

    if (!(0, _path.isAbsolute)(this.options.context)) {
      return (0, _path.join)(String(compiler.options.context), this.options.context);
    }

    return this.options.context;
  }

}

<<<<<<< HEAD
exports.ESLintWebpackPlugin = ESLintWebpackPlugin;
=======
>>>>>>> e746c2bfaec608273ddba2a9c3f88698eea4a1d6
var _default = ESLintWebpackPlugin;
exports.default = _default;